// Code generated by SQLBoiler 4.19.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// UpdateRecipient is an object representing the database table.
type UpdateRecipient struct {
	SenderID       null.Int    `boil:"sender_id" json:"sender_id,omitempty" toml:"sender_id" yaml:"sender_id,omitempty"`
	SenderEmail    null.String `boil:"sender_email" json:"sender_email,omitempty" toml:"sender_email" yaml:"sender_email,omitempty"`
	RecipientID    null.Int    `boil:"recipient_id" json:"recipient_id,omitempty" toml:"recipient_id" yaml:"recipient_id,omitempty"`
	RecipientEmail null.String `boil:"recipient_email" json:"recipient_email,omitempty" toml:"recipient_email" yaml:"recipient_email,omitempty"`
}

var UpdateRecipientColumns = struct {
	SenderID       string
	SenderEmail    string
	RecipientID    string
	RecipientEmail string
}{
	SenderID:       "sender_id",
	SenderEmail:    "sender_email",
	RecipientID:    "recipient_id",
	RecipientEmail: "recipient_email",
}

var UpdateRecipientTableColumns = struct {
	SenderID       string
	SenderEmail    string
	RecipientID    string
	RecipientEmail string
}{
	SenderID:       "update_recipients.sender_id",
	SenderEmail:    "update_recipients.sender_email",
	RecipientID:    "update_recipients.recipient_id",
	RecipientEmail: "update_recipients.recipient_email",
}

// Generated where

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_String) LIKE(x null.String) qm.QueryMod {
	return qm.Where(w.field+" LIKE ?", x)
}
func (w whereHelpernull_String) NLIKE(x null.String) qm.QueryMod {
	return qm.Where(w.field+" NOT LIKE ?", x)
}
func (w whereHelpernull_String) ILIKE(x null.String) qm.QueryMod {
	return qm.Where(w.field+" ILIKE ?", x)
}
func (w whereHelpernull_String) NILIKE(x null.String) qm.QueryMod {
	return qm.Where(w.field+" NOT ILIKE ?", x)
}
func (w whereHelpernull_String) SIMILAR(x null.String) qm.QueryMod {
	return qm.Where(w.field+" SIMILAR TO ?", x)
}
func (w whereHelpernull_String) NSIMILAR(x null.String) qm.QueryMod {
	return qm.Where(w.field+" NOT SIMILAR TO ?", x)
}
func (w whereHelpernull_String) IN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_String) NIN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var UpdateRecipientWhere = struct {
	SenderID       whereHelpernull_Int
	SenderEmail    whereHelpernull_String
	RecipientID    whereHelpernull_Int
	RecipientEmail whereHelpernull_String
}{
	SenderID:       whereHelpernull_Int{field: "\"update_recipients\".\"sender_id\""},
	SenderEmail:    whereHelpernull_String{field: "\"update_recipients\".\"sender_email\""},
	RecipientID:    whereHelpernull_Int{field: "\"update_recipients\".\"recipient_id\""},
	RecipientEmail: whereHelpernull_String{field: "\"update_recipients\".\"recipient_email\""},
}

var (
	updateRecipientAllColumns            = []string{"sender_id", "sender_email", "recipient_id", "recipient_email"}
	updateRecipientColumnsWithoutDefault = []string{}
	updateRecipientColumnsWithDefault    = []string{"sender_id", "sender_email", "recipient_id", "recipient_email"}
	updateRecipientPrimaryKeyColumns     = []string{}
	updateRecipientGeneratedColumns      = []string{}
)

type (
	// UpdateRecipientSlice is an alias for a slice of pointers to UpdateRecipient.
	// This should almost always be used instead of []UpdateRecipient.
	UpdateRecipientSlice []*UpdateRecipient
	// UpdateRecipientHook is the signature for custom UpdateRecipient hook methods
	UpdateRecipientHook func(context.Context, boil.ContextExecutor, *UpdateRecipient) error

	updateRecipientQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	updateRecipientType           = reflect.TypeOf(&UpdateRecipient{})
	updateRecipientMapping        = queries.MakeStructMapping(updateRecipientType)
	updateRecipientInsertCacheMut sync.RWMutex
	updateRecipientInsertCache    = make(map[string]insertCache)
	updateRecipientUpdateCacheMut sync.RWMutex
	updateRecipientUpdateCache    = make(map[string]updateCache)
	updateRecipientUpsertCacheMut sync.RWMutex
	updateRecipientUpsertCache    = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
	// These are used in some views
	_ = fmt.Sprintln("")
	_ = reflect.Int
	_ = strings.Builder{}
	_ = sync.Mutex{}
	_ = strmangle.Plural("")
	_ = strconv.IntSize
)

var updateRecipientAfterSelectMu sync.Mutex
var updateRecipientAfterSelectHooks []UpdateRecipientHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *UpdateRecipient) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range updateRecipientAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddUpdateRecipientHook registers your hook function for all future operations.
func AddUpdateRecipientHook(hookPoint boil.HookPoint, updateRecipientHook UpdateRecipientHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		updateRecipientAfterSelectMu.Lock()
		updateRecipientAfterSelectHooks = append(updateRecipientAfterSelectHooks, updateRecipientHook)
		updateRecipientAfterSelectMu.Unlock()
	}
}

// One returns a single updateRecipient record from the query.
func (q updateRecipientQuery) One(ctx context.Context, exec boil.ContextExecutor) (*UpdateRecipient, error) {
	o := &UpdateRecipient{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for update_recipients")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all UpdateRecipient records from the query.
func (q updateRecipientQuery) All(ctx context.Context, exec boil.ContextExecutor) (UpdateRecipientSlice, error) {
	var o []*UpdateRecipient

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to UpdateRecipient slice")
	}

	if len(updateRecipientAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all UpdateRecipient records in the query.
func (q updateRecipientQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count update_recipients rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q updateRecipientQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if update_recipients exists")
	}

	return count > 0, nil
}

// UpdateRecipients retrieves all the records using an executor.
func UpdateRecipients(mods ...qm.QueryMod) updateRecipientQuery {
	mods = append(mods, qm.From("\"update_recipients\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"update_recipients\".*"})
	}

	return updateRecipientQuery{q}
}
